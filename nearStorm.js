/**
 * 今年も台風の季節がやってきました。天気が悪いときはできれば、家から出たくないものです。
 *
 * あなたはそれでも会社に行かなければいけないかもしれません。
 * しかし、あなたが勤めている会社は、あまりに天気が悪く会社に行くことができない場合、自宅待機するよう決められています。
 *
 * 自宅から会社までの道で、降水量が一定値以上の箇所が一箇所でもある場合、その道は通れないとし、会社に行くことができません。
 * しかし、自宅から会社に行くことのできる道は複数あるので、どれか一つでも通行できる道がある場合は、その道を使って会社にいかなければなりません。
 * あなたには、複数の道と降水量の情報が以下のような地図として与えられます。
 *
 * 自宅を上側、会社を下側におきます。自宅から会社の間を N × N マス目で区切り、各マスの地区には降水量を表す整数が書かれています。
 * 図1
 *
 * あなたは複数ある列のどれか 1 つを選び、下に向かってまっすぐ進むことしかできません。途中で他の列に移動したり、戻ることはできません。
 * もし進んでいる道の途中で、降水量が一定値以上の箇所がある場合、その道は通ることができません。
 * あなたはどうしても会社に行きたくないので、会社に行くことができるルートを確認するプログラムを作成してください。
 *
 * 入力例 1 では降水量が 200 以上の場合通れないので、3 番目の道を通ることができてしまいます。
 * 図2
 *
 * 入力例 2 の場合は降水量が 100 以上の場合通れないので、全ての道が通ることができなく、あなたは会社にいかなくて良いです。
 * 図3
 *
 * 評価ポイント
 * 10回のテストケースで、正答率、実行速度、メモリ消費量をはかり得点が決まります。
 * より早い解答時間で提出したほうが得点が高くなります。
 * 複数のテストケースで正しい出力がされるか評価（+50点）
 * 解答までの速さ評価（+50点）
 * 入力される値
 * 入力は以下のフォーマットで与えられます。
 *
 * N M
 * p_{1,1} p_{1,2} ... p_{1,N}
 * p_{2,1} p_{2,2} ... p_{2,N}
 * ...
 * p_{N,1} p_{N,2} ... p_{N,N}
 * ・1 行目にそれぞれ地図のサイズ、通ることのできない降水量を表す整数 N, M がこの順で半角スペース区切りで与えられます。
 * ・続く N 行のうちの i 行目 (1 ≦ i ≦ N) には N 個の整数が半角スペース区切りで与えられます。i 行目の j 番目 (1 ≦ j ≦ N) の整数 p_{i, j} は i 行 j 列目の降水量を表します。
 * ・入力は合計で N + 1 行となり、入力値最終行の末尾に改行が 1 つ入ります。
 *
 * それぞれの値は文字列で標準入力から渡されます。標準入力からの値取得方法はこちらをご確認ください
 * 期待する出力
 * 会社に行くことができる場合は、すべての通ることのできるルートの番号を以下の形式で出力してください。
 * r_1 r_2 ...
 * ・期待する出力は 1 行からなります。
 * ・通ることのできるルートの番号を小さい順に r_1, r_2, ... として、半角スペース区切りで全て出力してください。
 * ・末尾に改行を入れ、余計な文字、空行を含んではいけません。
 * 自宅待機で良い場合は、
 * wait
 * と、出力してください。
 *
 * 条件
 * すべてのテストケースにおいて、以下の条件をみたします。
 *
 * ・1 ≦ N ≦ 10
 * ・1 ≦ M ≦ 1,000
 * ・0 ≦ p_{i ,j} ≦ 1,000 (1 ≦ i, j ≦ N)
 */

//入力値を切り替える。
const lines = ["3 200","100 200 20",
                       "100 20 20",
                       "500 20 20"]//出力: 3

// const lines = ["3 100", "1000 1000 1000",
//                         "1000 1000 1000",
//                         "1000 1000 1000",] //出力: wait

// const lines = ["3 50", "40 40 40",
//                        "40 40 40",
//                        "40 40 40",] //出力: 1 2 3

// const lines = ["6 709", "162 255 267 207 259 5",
//                         "40 115 179 292 79 57",
//                         "98 116 284 866 283 280",
//                         "166 84 265 42 300 157",
//                         "288 258 163 121 239 188",
//                         "57 66 239 141 59 33"]; //出力: 1 2 3 5 6

// const lines = ["5 50", "10 40 40 40 30",
//                        "40 40 40 40 30",
//                        "40 40 40 50 90",
//                        "30 20 10 40 100",
//                        "40 50 30 30 10"]; //出力: 1 3

const nearStorm = () => {
    const [routes, rainStandards] = lines[0].split(" ");
    let array = [];
    for (let i = 1; i <= routes; i++) {
        array.push(lines[i].split(" "));
    }
    const transpose = a => a[0].map((_, c) => a.map(r => r[c]));
    const roadArrs = transpose(array);

    const isRoad = roadArrs.map((roadArr) => {
        return roadArr.flatMap((num) => (Number(num) < Number(rainStandards)));
    });
    let go = [];
    let wait = 0;
    isRoad.forEach((isArr, index) => {
        if (isArr.every((is) => is)) {
            go.push(index + 1);
        } else {
            wait++;
        }
    });
    if (wait == routes) {
        console.log("wait");
    } else {
        console.log(go.join(" "));
    }
};
nearStorm();